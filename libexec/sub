#!/usr/bin/env bash
set -e

resolve_link() {
  $(type -p greadlink readlink | head -1) "$1"
}

abs_dirname() {
  local cwd="$(pwd)"
  local path="$1"

  while [ -n "$path" ]; do
    cd "${path%/*}"
    local name="${path##*/}"
    path="$(resolve_link "$name" || true)"
  done

  pwd
  cd "$cwd"
}

debug()
{
  test -z "$DEBUG" || echo DEBUG: "$@"
}

# ---------------------------------------------------------------------------
# Given a command line with tokens representing both the subcommand structure
# and eventually the arguments for a command, figure out the path to the
# command and indicate how many arguments from the command need to be shifted
# so that all that remains is the command arguments.
# 
# The results are stored in the following variables:
# 
#   COMMAND_PATH    Contains the full path to the command, which can be
#                   either a file or a directory.
# 
#   COMMAND         An array with the tokens that lead up to the command,
#                   not including the arguments for such.
# 
#   SHIFT           The number of tokens consumed in the full command line at
#                   the time the command was finally found. This can be used
#                   as an argument for shift to leave only the commands
#                   arguments in the list of arguments.
# ---------------------------------------------------------------------------
function find_command_path()
{
  # Output variables
  declare -i SHIFT=0
  COMMAND_PATH=''
  COMMAND=()
  # ------------------
  local running_path="$_SUB_ROOT/libexec"
  local token
  for (( i = 1; i <= $#; i++ )); do
    token="${!i}"
    # If we still have not resolved the script name and we are already seeing
    # flags in the command line, no chance. Try at least to run the directory
    # thing at the bottom.
    if [[ $token == -* ]]; then
        break
    fi
    SHIFT=$i
    COMMAND+=("$token")
    debug SHIFT $SHIFT
    debug TOKEN: $token
    local possible_path="$running_path/sub-$token"
    local possible_path_sh="$running_path/sub-sh-$token"
    # If the current token is part of the path but no the script, just add to
    # running path.
    if [[ -d $possible_path ]]; then
      running_path="$possible_path"
      debug FOUND DIR: $possible_path
      continue
    # But if the current token is the script, set the path and return.
    elif [[ -x  $possible_path ]]; then
      debug FOUND_FILE: $possible_path
      COMMAND_PATH="$possible_path"
      return
    elif [[ -x  $possible_path_sh ]]; then
      debug FOUND_FILE: $possible_path_sh
      COMMAND_PATH="$possible_path_sh"
      return
    # Otherwise, we have a token that is not a directory and appears before the
    # script is found. This is an error.
    else
      debug NOT FOUND: $possible_path
      return
    fi
  done

  # We are here because we have run out of arguments and we have not found a
  # script. The last element in the command entered was the name of a sub-sub
  # directory.
  if [[ -n $running_path ]]; then
    COMMAND_PATH="$running_path"
    return
  fi

  return
}

libexec_path="$(abs_dirname "$0")"
export _SUB_ROOT="$(abs_dirname "$libexec_path")"
# Add the libexec directory to the PATH
export PATH="${libexec_path}:$PATH"

command="$1"
case "$command" in
"" | "-h" | "--help")
  exec sub-help
  ;;
* )
  find_command_path "$@"
  shift $SHIFT
  # If we ended up with a directory, show help for that directory
  if [[ -d $COMMAND_PATH ]]; then
      debug Running help with path "$COMMAND_PATH"
      exec sub-help "$COMMAND_PATH" ${COMMAND[@]}
  fi
  if [ ! -x "$COMMAND_PATH" ]; then
    echo "sub: no such command \`${COMMAND[@]}'" >&2
    exit 1
  fi
  exec "$COMMAND_PATH" "$@"
  ;;
esac
