#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Sub: a script organization tool.
"""

import sys
import os
import glob
import logging


SUBNAME = 'sub'

DEBUGGING = False

if 'SUBDEBUG' in os.environ:
    logging.basicConfig(filename='sub.log', level=logging.DEBUG)
    DEBUGGING = True

def DEBUG(msg):
    if DEBUGGING:
        logging.debug(msg)

def traced(f):
    if not DEBUGGING:
        return f
    def wrapped(*args, **kwargs):
        if f.__name__ == 'main':
            logging.debug("SUB: --------------------------------------------------------------------")
            logging.debug("SUB: Running %s %s" % (SUBNAME, " ".join(args[0][1:])))
            logging.debug("SUB: --------------------------------------------------------------------")
        logging.debug("TRACE: Entering %s with args: %s, %s" % (f.__name__, args, kwargs))
        return f(*args, **kwargs)
    wrapped.__name__ = f.__name__
    wrapped.__doc__ = f.__doc__
    return wrapped

@traced
def path_prepend(directory):
    """
    Add a given directory to the beginning of the PATH environment variable.
    """
    os.environ['PATH'] = u"%s:%s" % (directory, os.environ['PATH'] )

@traced
def mkcmd(command, shFlag = False):
    """
    Return a string with the name of a command in this sub.
    """
    return u"%s%s-%s" % (SUBNAME, ('-sh' if shFlag else ''), command)


@traced
def die(error):
    """
    Show message on stderr and exit
    """
    sys.stderr.write(error)
    sys.stderr.flush()
    sys.exit(1)


@traced
def sub_help(help_args = None):
    """
    Run the help subcommand
    """
    if help_args is None:
        help_args = []
    help_command = mkcmd('help')
    os.execvp(help_command, [help_command] + help_args)


@traced
def print_container_commands(container_path, sh_flag = None):
    """
    Print the commands available in a given path
    """
    glob_pattern = os.path.join(container_path, mkcmd('*'))
    commands = []
    for command in glob.iglob(glob_pattern):
        # Leave only the command name without prefix
        command = command[len(glob_pattern)-1:]
        # If it is an 'sh-type' command, also remove the 'sh-' prefix
        is_sh = command.startswith('sh-')
        if is_sh:
            if sh_flag is None or sh_flag == True:
                commands.append(command[3:])
        else:
            if sh_flag is None or sh_flag == False:
                commands.append(command)
    # sort | uniq, python style
    for cmd in sorted(set(commands)):
        print cmd


@traced
def sub_commands(command, libexec_path):
    """
    Run the commands subcommand
    """
    sh_flag = None
    if command:
        if command[0] == '--sh':
            sh_flag = True
            command.pop(0)
        elif command[0] == '--no-sh':
            sh_flag = False
            command.pop(0)
    # Find the path to the container
    container_path = os.path.join(libexec_path, *[ mkcmd(c) for c in command])

    if os.path.isdir(container_path):
        print_container_commands(container_path, sh_flag)
        return True
    return False

@traced
def find_command_path(start_dir, argv):
    """
    Given a command line with tokens representing both the subcommand structure
    and eventually the arguments for a command, figure out the path to the
    command and extract the items from the command line that are to be passed
    as parameters of that command.

    Returns a tuple with the following:
        * The full path to the command, which can be either a file or a
          directory. This will be None if the command cannot be found.
        * A list of the tokens that lead up to the command, not including the
          arguments for such. This is always set.
        * The arguments to be passed to the command. this will be None if the
          command cannot be found.
    """
    running_path = start_dir
    shift = 0
    command = []
    for (shift, token) in enumerate(argv):

        # If we still have not resolved the script name and we are already
        # seeing flags in the command line. This means user passing flags to a
        # container, which is not supported, so just jump out and show help for
        # the container that has been built so far.
        if token[0] == '-':
            break
        command.append(token)
        possible_path = os.path.join(running_path, mkcmd(token))

        # If the current token is part of the path but no the script, just add
        # to running path and keep looking.
        if os.path.isdir(possible_path):
            running_path = possible_path
            continue

        # But if the current token is the script, set the path and return.
        if os.access(possible_path, os.X_OK):
            running_path = possible_path
            break

        # Perhaps it's an "sh-type" script
        possible_path_sh = os.path.join(running_path, mkcmd(token, shFlag=True))
        if os.access(possible_path_sh, os.X_OK):
            running_path=possible_path_sh
            break

        # Otherwise, we have a token that is not a directory and appears before
        # the script is found. This is an error. Make sure we still return the
        # command, so it can be shown in the error.
        return (None, command, None)

    return (running_path, command, argv[shift+1:])

@traced
def provides_completions(command_path):
    """
    Check wether certain file declares to provide completion for the current
    sub.
    """
    compl_line = "# provide %s completions" % SUBNAME

    with file(command_path, 'r') as fin:
        for line in fin:
            if line.lower().startswith(compl_line):
                return True
    return False

@traced
def sub_completions(command, libexec_path):
    """
    Run the completions subcommand
    """
    if len(command) == 0:
        die("usage: %s completions COMMAND [arg1 arg2...]" % SUBNAME)
    # Pass all arguments but last
    (command_path, command, flags) = find_command_path(libexec_path, command[:-1])
    if command_path is None:
        DEBUG ("COMPLETIONS: COMMAND %s not found" % (command[:-1]))
        return True
    elif os.path.isdir(command_path):
        DEBUG ("COMPLETIONS: Will complete with commands in container: %s" % command_path)
        return sub_commands(command, libexec_path)
    elif provides_completions(command_path):
        DEBUG("Will complete by alling script %s" % command_path)
        os.execvp(command_path, [command_path, '--complete'])
    else:
        DEBUG("COMPLETIONS: %s does not provide completions" % command_path)



@traced
def main(argv=[__name__]):
    """ Run this program """
    args = argv[1:]
    try:
        # Add this sub's main directory to the environment
        libexec_path = os.path.dirname(os.path.realpath(__file__))
        sub_root_env_name = "_%s_ROOT" % SUBNAME.upper()
        os.environ[sub_root_env_name] = os.path.dirname(libexec_path)

        # And also add the libexec directory to the PATH
        path_prepend(libexec_path)

        # If user is just asking for help, give them help
        if len(args) < 1 or args[0] in ('-h', '--help'):
            sub_help()

        # The 'commands' subcommand is handled here, there is no need to
        # dispatch to external script.
        if args[0] == 'commands':
            DEBUG('SUB: handling "commands" subcommand')
            args.pop(0)
            ret = sub_commands(args, libexec_path)
            return 0 if ret else 1

        # The completions subcommand is also handled internally
        if args[0] == 'completions':
            DEBUG('SUB: handling "completions" subcommand')
            args.pop(0)
            ret = sub_completions(args, libexec_path)
            return 0 if ret else 1

        DEBUG('SUB: will attempt to find subcommand with args: %s' % args)

        # Find the path to the requested subcommand
        (command_path, command, flags) = find_command_path(libexec_path, args)

        # If we ended up with a directory, show help for that directory
        if command_path is not None and os.path.isdir(command_path):
            DEBUG("SUB: subcommand %s is a container. Showing help" % command)
            sub_help([command_path] + command)

        # We could not find the command, show error
        if command_path is None or not os.access(command_path, os.X_OK):
            DEBUG("SUB: subcommand %s was not found. Showing error" % command)
            die("%s: no such command `%s'\n" % (SUBNAME, ' '.join(command)))

        # Or everything went well, so run the command
        DEBUG("SUB: subcommand %s was found. Executing with args: %s" % (command, flags))
        os.execvp(command_path, [command_path] + flags)


    except KeyboardInterrupt:
        sys.exit(-1)

if __name__ == '__main__':
    sys.exit(main(sys.argv) or 0)
