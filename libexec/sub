#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Sub: a script organization tool.
"""

import sys
import os
import glob
import logging


# Globals
SUBNAME = 'sub'
sub_root = None
libexec_path = None

# Configure logging
# -----------------------------------------------------------------------------
# Enable logging by setting the SUBDEBUG environment variable to any value
# -----------------------------------------------------------------------------
DEBUGGING = False

if 'SUBDEBUG' in os.environ:
    logging.basicConfig(filename='sub.log', level=logging.DEBUG)
    DEBUGGING = True
    debug_prefix = SUBNAME.upper()
# -----------------------------------------------------------------------------

def decorator(dec):
    """
    A decorator-decorator. Keeps all decorator boilerplate together so that it
    does not have to be repeated in every decorator.

    It propagates the attributes of the original function to the decorated
    version.
    """
    def wrapped_decorator(f):
        g = dec(f)
        g.__name__ = f.__name__
        g.__doc__ = f.__doc__
        g.__dict__.update(f.__dict__)
        return g
    wrapped_decorator.__name__ = dec.__name__
    wrapped_decorator.__doc__ = dec.__doc__
    wrapped_decorator.__dict__.update(dec.__dict__)
    return wrapped_decorator

@decorator
def debugonly(f):
    """
    A decorator to turn any function into a noop when not in debugging mode.
    """
    if DEBUGGING:
        return f
    else:
        def noop(*args, **kwargs):
            pass
        return noop

@decorator
def traced(f):
    """
    A decorator to log a trace of the call to the decorated function, only in
    debugging mode.
    """
    if not DEBUGGING:
        return f

    def wrapped(*args, **kwargs):
        logging.debug("%s:TRACE: Entering %s with args: %s, %s" % (
                      debug_prefix, f.__name__, args, kwargs))
        return f(*args, **kwargs)

    def wrapped_main(*args, **kwargs):
        logging.debug("SUB: --------------------------------------------------------------------")
        logging.debug("SUB: Running %s %s" % (SUBNAME, " ".join(args[0][1:])))
        logging.debug("SUB: --------------------------------------------------------------------")
        logging.debug("SUB:TRACE: Entering %s with args: %s, %s" % (f.__name__, args, kwargs))
        return f(*args, **kwargs)

    newf = wrapped_main if f.__name__ == 'main' else wrapped
    return newf

@decorator
def command(f):
    """
    A decorator for commands implemented internally.

    It sets the logging prefix in debugging mode so that all log entries
    indicate the command that is being run.
    """
    if not DEBUGGING or not f.__name__.startswith('sub_'):
        return f
    command_name = f.__name__[4:]
    def wrapped(*args, **kwargs):
        global debug_prefix
        old_debug_prefix = debug_prefix
        DEBUG('Handling "%s" subcommand internally' % command_name)
        debug_prefix = command_name.upper()
        r = f(*args, **kwargs)
        debug_prefix = old_debug_prefix
        return r
    return wrapped

@debugonly
def DEBUG(msg, *args, **kwargs):
    """
    Send debug messages to the log. Enabled only on debug mode.
    """
    logging.debug("%s: %s" % (debug_prefix, msg), *args, **kwargs)

# -----------------------------------------------------------------------------


@traced
def path_prepend(directory):
    """
    Add a given directory to the beginning of the PATH environment variable.
    """
    os.environ['PATH'] = u"%s:%s" % (directory, os.environ['PATH'] )


@traced
def mkcmd(command, shFlag = False):
    """
    Return a string with the name of a command in this sub.
    """
    return u"%s%s-%s" % (SUBNAME, ('-sh' if shFlag else ''), command)


@traced
def die(error):
    """
    Show message on stderr and exit
    """
    sys.stderr.write(error)
    sys.stderr.flush()
    sys.exit(1)


@traced
@command
def sub_help(help_args = None):
    """
    Run the help subcommand
    """
    if help_args is None:
        help_args = []
    help_command = mkcmd('help')
    os.execvp(help_command, [help_command] + help_args)


@traced
def print_container_commands(container_path, sh_flag = None):
    """
    Print the commands available in a given path
    """
    glob_pattern = os.path.join(container_path, mkcmd('*'))
    commands = []
    for command in glob.iglob(glob_pattern):
        DEBUG("command '%s' matched glob pattern '%s'", command, glob_pattern)
        # Leave only the command name without prefix
        command = command[len(glob_pattern)-1:]
        # If it is an 'sh-type' command, also remove the 'sh-' prefix
        is_sh = command.startswith('sh-')
        if is_sh:
            if sh_flag is None or sh_flag == True:
                commands.append(command[3:])
        else:
            if sh_flag is None or sh_flag == False:
                commands.append(command)
    # sort | uniq, python style
    DEBUG("These commands passed the filter: %s", commands)
    for cmd in sorted(set(commands)):
        print cmd


@traced
@command
def sub_commands(command):
    """
    Run the commands subcommand
    """
    sh_flag = None
    if command:
        if command[0] == '--sh':
            sh_flag = True
            command.pop(0)
        elif command[0] == '--no-sh':
            sh_flag = False
            command.pop(0)
    # Find the path to the container
    container_path = os.path.join(libexec_path, *[ mkcmd(c) for c in command])

    if os.path.isdir(container_path):
        DEBUG("Container path %s exists", container_path)
        print_container_commands(container_path, sh_flag)
        return True
    return False


@traced
def find_command_path(start_dir, argv):
    """
    Given a command line with tokens representing both the subcommand structure
    and eventually the arguments for a command, figure out the path to the
    command and extract the items from the command line that are to be passed
    as parameters of that command.

    Returns a tuple with the following:
        * The full path to the command, which can be either a file or a
          directory. This will be None if the command cannot be found.
        * A list of the tokens that lead up to the command, not including the
          arguments for such. This is always set.
        * The arguments to be passed to the command. this will be None if the
          command cannot be found.
    """
    running_path = start_dir
    shift = 0
    command = []
    for (shift, token) in enumerate(argv):

        # If we still have not resolved the script name and we are already
        # seeing flags in the command line. This means user passing flags to a
        # container, which is not supported, so just jump out and show help for
        # the container that has been built so far.
        if token[0] == '-':
            break
        command.append(token)
        possible_path = os.path.join(running_path, mkcmd(token))

        # If the current token is part of the path but no the script, just add
        # to running path and keep looking.
        if os.path.isdir(possible_path):
            running_path = possible_path
            continue

        # But if the current token is the script, set the path and return.
        if os.access(possible_path, os.X_OK):
            running_path = possible_path
            break

        # Perhaps it's an "sh-type" script
        possible_path_sh = os.path.join(running_path, mkcmd(token, shFlag=True))
        if os.access(possible_path_sh, os.X_OK):
            running_path=possible_path_sh
            break

        # Otherwise, we have a token that is not a directory and appears before
        # the script is found. This is an error. Make sure we still return the
        # command, so it can be shown in the error.
        return (None, command, None)

    return (running_path, command, argv[shift+1:])


@traced
def provides_completions(command_path):
    """
    Check wether certain file declares to provide completion for the current
    sub.
    """
    compl_line = "# provide %s completions" % SUBNAME

    with file(command_path, 'r') as fin:
        for line in fin:
            if line.lower().startswith(compl_line):
                return True
    return False


@traced
@command
def sub_completions(command):
    """
    Run the completions subcommand
    """
    if len(command) == 0:
        die("usage: %s completions COMMAND [arg1 arg2...]" % SUBNAME)
    # Pass all arguments but last
    (command_path, command, flags) = find_command_path(libexec_path, command[:-1])
    if command_path is None:
        DEBUG ("command %s not found" % (command[:-1]))
        return True
    elif os.path.isdir(command_path):
        DEBUG ("Will complete with commands in container: %s" % command_path)
        return sub_commands(command)
    elif provides_completions(command_path):
        DEBUG("Will complete by calling script %s --complete" % command_path)
        os.execvp(command_path, [command_path, '--complete'])
    else:
        DEBUG("%s does not provide completions" % command_path)


@traced
@command
def sub_init(args):
    """
    Run the init subcommand
    """
    do_print = args and args[0] == '-'
    if do_print:
        args.pop(0)
        DEBUG("Called by shell")
    else:
        DEBUG("Called by user")

    # Figure out the shell
    if args:
        shell = args.pop(0)
    else:
        shell = os.path.basename(os.environ.get('SHELL', ''))

    # Profile files for supported shells
    profiles = dict(
        bash = '~/.bash_profile',
        zsh  = '~/.zshenv'
        )

    # Common arguments for all subsequent strings
    fmt_args = dict(
            sub      = SUBNAME,
            profile  = profiles.get(shell, 'your profile'),
            sub_root = sub_root,
            shell    = shell
            )

    DEBUG("Common arguments for strings: %s" % fmt_args)

    if not do_print:
        from textwrap import dedent as dd
        msg = dd("""\
            # Load %(sub)s automatically by adding
            # the following to %(profile)s:

            eval "$(%(sub_root)s/bin/%(sub)s init -)"

            """ % fmt_args )
        if shell not in profiles:
            msg += dd("""\
                # Warning: %(sub)s has no support for either 'sh' commands or
                # completions in your shell '%(shell)s'

                """ % fmt_args )
        # Print message to stderr and exit
        die(msg)

    # alternatively, if init is being called to get its out output evalled:

    # Add to PATH
    print 'export PATH="%s:%s/bin"' % (os.environ['PATH'], sub_root)

    if shell in profiles:
        from textwrap import dedent as dd
        print dd("""\
        source "%(sub_root)s/completions/sub.%(shell)s"
        _sub_wrapper() {
            if [[ -z $1 ]]; then
                command %(sub)s
                return $?
            fi
            local running_path=%(sub_root)s/libexec
            local running_command
            local cmd=""
            for command in $@
            do
                if [[ -d $running_path/sub-$command ]]; then
                    running_path=$running_path/sub-$command
                    running_command="$running_command $command"
                    shift
                    continue
                elif [[ -f $running_path/sub-sh-$command ]]; then
                    cmd="$running_command sh-$command"
                    shift
                else
                    command %(sub)s $running_command "$@"
                    return $?
                fi

                if [[ -n $cmd ]]; then
                    eval "$(command %(sub)s $cmd "$@")"
                    return $?
                fi
            done
            command %(sub)s $running_command "$@"
        }
        """ % fmt_args)
        if shell == 'bash':
            print "alias %(sub)s=_%(sub)s_wrapper" % fmt_args
        elif shell == 'zsh':
            print "%(sub)s=_%(sub)s_wrapper" % fmt_args


@traced
def main(argv=[__name__]):
    """ Run this program """
    args = argv[1:]
    global sub_root
    global libexec_path
    try:
        # Add this sub's main directory to the environment
        libexec_path = os.path.dirname(os.path.realpath(__file__))
        sub_root = os.path.dirname(libexec_path)

        DEBUG("libexec_path = %s, sub_root = %s", libexec_path, sub_root)

        sub_root_env_name = "_%s_ROOT" % SUBNAME.upper()
        os.environ[sub_root_env_name] = sub_root

        # And also add the libexec directory to the PATH
        path_prepend(libexec_path)

        # If user is just asking for help, give them help
        if len(args) < 1 or args[0] in ('-h', '--help'):
            sub_help()

        # The 'commands' subcommand is handled here, there is no need to
        # dispatch to external script.
        if args[0] == 'commands':
            args.pop(0)
            ret = sub_commands(args)
            return 0 if ret else 1

        # The completions subcommand is also handled internally
        if args[0] == 'completions':
            args.pop(0)
            ret = sub_completions(args)
            return 0 if ret else 1

        # Handling internal 'init' subcommand
        if args[0] == 'init':
            args.pop(0)
            ret = sub_init(args)
            return 0 if ret else 1

        DEBUG('will attempt to find subcommand with args: %s' % args)

        # Find the path to the requested subcommand
        (command_path, command, flags) = find_command_path(libexec_path, args)

        # If we ended up with a directory, show help for that directory
        if command_path is not None and os.path.isdir(command_path):
            DEBUG("subcommand %s is a container. Showing help" % command)
            sub_help([command_path] + command)

        # We could not find the command, show error
        if command_path is None or not os.access(command_path, os.X_OK):
            DEBUG("subcommand %s was not found. Showing error" % command)
            die("%s: no such command `%s'\n" % (SUBNAME, ' '.join(command)))

        # Or everything went well, so run the command
        DEBUG("subcommand %s was found. Executing with args: %s" % (command, flags))
        os.execvp(command_path, [command_path] + flags)


    except KeyboardInterrupt:
        sys.exit(-1)


if __name__ == '__main__':
    sys.exit(main(sys.argv) or 0)
